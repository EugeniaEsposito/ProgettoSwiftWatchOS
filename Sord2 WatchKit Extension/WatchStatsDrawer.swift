//
//  StatsWatch.swift
//  MiniMe
//
//  Created by SimoneSoldo on 21/07/2017.
//  Copyright Â© 2017 MeTeam. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class WatchStatsDrawer : NSObject {

    //// Drawing Methods

    @objc public dynamic class func drawActivityRed(wellnessLevel: CGFloat = 0.163, frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 156, height: 195), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 156, height: 195), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 156, y: resizedFrame.height / 195)


        //// Color Declarations
        let wellness1 = UIColor(red: 1.000, green: 0.298, blue: 0.298, alpha: 1.000)
//        let wellness2 = UIColor(red: 1.000, green: 0.082, blue: 0.035, alpha: 1.000)
        
        //// Gradient Declarations
//        let wellnessgradient = CGGradient(colorsSpace: nil, colors: [wellness1.cgColor, wellness2.cgColor] as CFArray, locations: [0, 1])!
        
        //// Variable Declarations
        let wellnessDash: CGFloat = wellnessLevel * 408 + 6

        //// ColorGroup
        //// MaskOval Drawing
        let maskOvalPath = UIBezierPath(ovalIn: CGRect(x: 4, y: 26, width: 148, height: 148))
        context.saveGState()
        maskOvalPath.addClip()
        wellness1.setFill()
        maskOvalPath.fill()
//        context.drawLinearGradient(wellnessgradient, start: CGPoint(x: 78, y: 26), end: CGPoint(x: 78, y: 174), options: [])
        context.restoreGState()



        //// MaskGroup
        context.saveGState()
        context.translateBy(x: 78, y: 100)
        context.rotate(by: 90 * CGFloat.pi/180)

        context.setBlendMode(.destinationIn)
        context.beginTransparencyLayer(auxiliaryInfo: nil)


        //// MoveMask Drawing
        let moveMaskPath = UIBezierPath()
        moveMaskPath.move(to: CGPoint(x: -65, y: 0))
        moveMaskPath.addCurve(to: CGPoint(x: 0, y: -65), controlPoint1: CGPoint(x: -65, y: -35.9), controlPoint2: CGPoint(x: -35.9, y: -65))
        moveMaskPath.addCurve(to: CGPoint(x: 65, y: 0), controlPoint1: CGPoint(x: 35.9, y: -65), controlPoint2: CGPoint(x: 65, y: -35.9))
        moveMaskPath.addCurve(to: CGPoint(x: -0, y: 65), controlPoint1: CGPoint(x: 65, y: 35.9), controlPoint2: CGPoint(x: 35.9, y: 65))
        moveMaskPath.addCurve(to: CGPoint(x: -65, y: 0), controlPoint1: CGPoint(x: -35.9, y: 65), controlPoint2: CGPoint(x: -65, y: 35.9))
        moveMaskPath.close()
        UIColor.black.setStroke()
        moveMaskPath.lineWidth = 19
        moveMaskPath.lineCapStyle = .round
        context.saveGState()
        context.setLineDash(phase: 1, lengths: [wellnessDash, 408])
        moveMaskPath.stroke()
        context.restoreGState()

        context.endTransparencyLayer()

        context.restoreGState()
        
        context.restoreGState()

    }

    @objc public dynamic class func drawActivityCompositionRed(wellnessLevel: CGFloat = 0.163, frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 156, height: 195), resizing: ResizingBehavior = .aspectFit) -> UIImage {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!

        //// Color Declarations
        let wellness1 = UIColor(red: 0.086, green: 0.800, blue: 0.063, alpha: 1.000)
        var wellness1HueComponent: CGFloat = 1
        var wellness1SaturationComponent: CGFloat = 1
        var wellness1BrightnessComponent: CGFloat = 1
        wellness1.getHue(&wellness1HueComponent, saturation: &wellness1SaturationComponent, brightness: &wellness1BrightnessComponent, alpha: nil)

//        let wellnessBkg = UIColor(red: 0.110, green: 1.000, blue: 0.078, alpha: 1.000)
        
        //// Image Declarations
        /*let hearth = UIImage(named: "hearth.png")!
        let footstepssilhouettevariant = UIImage(named: "footstepssilhouettevariant.png")!
        let halfmoon = UIImage(named: "halfmoon.png")!*/

        //// ColorGroup
        //// MaskOval Drawing
        let maskOvalPath = UIBezierPath(ovalIn: CGRect(x: 4, y: 26, width: 148, height: 148))
        wellness1.setFill()
        maskOvalPath.fill()


        //// SymbolGroup
        context.saveGState()
        context.setBlendMode(.sourceAtop)
        context.beginTransparencyLayer(auxiliaryInfo: nil)


        //// Symbol Drawing
        let symbolRect = targetFrame
        context.saveGState()
        context.clip(to: symbolRect)
        context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

        WatchStatsDrawer.drawActivityRed(wellnessLevel: wellnessLevel, frame: CGRect(origin: .zero, size: symbolRect.size), resizing: resizing)
        context.restoreGState()


        context.endTransparencyLayer()
        context.restoreGState()


        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 22, y: 44, width: 112, height: 112))
        UIColor.black.setFill()
        ovalPath.fill()


        //// Picture Drawing
        context.saveGState()
        context.translateBy(x: 71, y: 28)
        context.scaleBy(x: 0.15, y: 0.15)

        let picturePath = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 100, height: 100))
        context.saveGState()
        picturePath.addClip()
        context.translateBy(x: 0, y: 0)
        context.scaleBy(x: 1, y: -1)
//        context.translateBy(x: 0, y: -hearth.size.height)
//        context.draw(hearth.cgImage!, in: CGRect(x: 0, y: 0, width: hearth.size.width, height: hearth.size.height))
        context.restoreGState()

        context.restoreGState()


        //// Picture 2 Drawing
        context.saveGState()
        context.translateBy(x: 71, y: 46.92)
        context.scaleBy(x: 0.11, y: 0.11)

        let picture2Path = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 128, height: 128))
        context.saveGState()
        picture2Path.addClip()
        context.translateBy(x: 0, y: 0)
        context.scaleBy(x: 1, y: -1)
//        context.translateBy(x: 0, y: -footstepssilhouettevariant.size.height)
//        context.draw(footstepssilhouettevariant.cgImage!, in: CGRect(x: 0, y: 0, width: footstepssilhouettevariant.size.width, height: footstepssilhouettevariant.size.height))
        context.restoreGState()

        context.restoreGState()


        //// Picture 3 Drawing
        context.saveGState()
        context.translateBy(x: 70, y: 63.44)
        context.scaleBy(x: 0.06, y: 0.06)

        let picture3Path = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 280, height: 276))
        context.saveGState()
        picture3Path.addClip()
        context.translateBy(x: 0, y: 0)
        context.scaleBy(x: 1, y: -1)
//        context.translateBy(x: 0, y: -halfmoon.size.height)
//        context.draw(halfmoon.cgImage!, in: CGRect(x: 0, y: 0, width: halfmoon.size.width, height: halfmoon.size.height))
        context.restoreGState()

        context.restoreGState()
        
        let cgimage = context.makeImage();
        return UIImage(cgImage: cgimage!)
        
//        return UIImage(cgImage: context.makeImage()!)
    }

    
    @objc public dynamic class func drawActivityRed2(wellnessLevel: CGFloat = 0.163, frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 156, height: 195), resizing: ResizingBehavior = .aspectFit) {
            //// General Declarations
            let context = UIGraphicsGetCurrentContext()!
            
            //// Resize to Target Frame
            context.saveGState()
            let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 156, height: 195), target: targetFrame)
            context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
            context.scaleBy(x: resizedFrame.width / 156, y: resizedFrame.height / 195)


            //// Color Declarations
            let wellness1 = UIColor(red: 0.898, green: 0.000, blue: 0.000, alpha: 1.000)
    //        let wellness2 = UIColor(red: 1.000, green: 0.082, blue: 0.035, alpha: 1.000)
            
            //// Gradient Declarations
    //        let wellnessgradient = CGGradient(colorsSpace: nil, colors: [wellness1.cgColor, wellness2.cgColor] as CFArray, locations: [0, 1])!
            
            //// Variable Declarations
            let wellnessDash: CGFloat = wellnessLevel * 408 + 6

            //// ColorGroup
            //// MaskOval Drawing
            let maskOvalPath = UIBezierPath(ovalIn: CGRect(x: 4, y: 26, width: 148, height: 148))
            context.saveGState()
            maskOvalPath.addClip()
            wellness1.setFill()
            maskOvalPath.fill()
    //        context.drawLinearGradient(wellnessgradient, start: CGPoint(x: 78, y: 26), end: CGPoint(x: 78, y: 174), options: [])
            context.restoreGState()



            //// MaskGroup
            context.saveGState()
            context.translateBy(x: 78, y: 100)
            context.rotate(by: 90 * CGFloat.pi/180)

            context.setBlendMode(.destinationIn)
            context.beginTransparencyLayer(auxiliaryInfo: nil)


            //// MoveMask Drawing
            let moveMaskPath = UIBezierPath()
            moveMaskPath.move(to: CGPoint(x: -65, y: 0))
            moveMaskPath.addCurve(to: CGPoint(x: 0, y: -65), controlPoint1: CGPoint(x: -65, y: -35.9), controlPoint2: CGPoint(x: -35.9, y: -65))
            moveMaskPath.addCurve(to: CGPoint(x: 65, y: 0), controlPoint1: CGPoint(x: 35.9, y: -65), controlPoint2: CGPoint(x: 65, y: -35.9))
            moveMaskPath.addCurve(to: CGPoint(x: -0, y: 65), controlPoint1: CGPoint(x: 65, y: 35.9), controlPoint2: CGPoint(x: 35.9, y: 65))
            moveMaskPath.addCurve(to: CGPoint(x: -65, y: 0), controlPoint1: CGPoint(x: -35.9, y: 65), controlPoint2: CGPoint(x: -65, y: 35.9))
            moveMaskPath.close()
            UIColor.black.setStroke()
            moveMaskPath.lineWidth = 19
            moveMaskPath.lineCapStyle = .round
            context.saveGState()
            context.setLineDash(phase: 1, lengths: [wellnessDash, 408])
            moveMaskPath.stroke()
            context.restoreGState()

            context.endTransparencyLayer()

            context.restoreGState()
            
            context.restoreGState()

        }

        @objc public dynamic class func drawActivityCompositionRed2(wellnessLevel: CGFloat = 0.163, frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 156, height: 195), resizing: ResizingBehavior = .aspectFit) -> UIImage {
            //// General Declarations
            let context = UIGraphicsGetCurrentContext()!

            //// Color Declarations
            let wellness1 = UIColor(red: 1.000, green: 0.298, blue: 0.298, alpha: 1.000)
            var wellness1HueComponent: CGFloat = 1
            var wellness1SaturationComponent: CGFloat = 1
            var wellness1BrightnessComponent: CGFloat = 1
            wellness1.getHue(&wellness1HueComponent, saturation: &wellness1SaturationComponent, brightness: &wellness1BrightnessComponent, alpha: nil)

    //        let wellnessBkg = UIColor(red: 0.110, green: 1.000, blue: 0.078, alpha: 1.000)
            
            //// Image Declarations
            /*let hearth = UIImage(named: "hearth.png")!
            let footstepssilhouettevariant = UIImage(named: "footstepssilhouettevariant.png")!
            let halfmoon = UIImage(named: "halfmoon.png")!*/

            //// ColorGroup
            //// MaskOval Drawing
            let maskOvalPath = UIBezierPath(ovalIn: CGRect(x: 4, y: 26, width: 148, height: 148))
            wellness1.setFill()
            maskOvalPath.fill()


            //// SymbolGroup
            context.saveGState()
            context.setBlendMode(.sourceAtop)
            context.beginTransparencyLayer(auxiliaryInfo: nil)


            //// Symbol Drawing
            let symbolRect = targetFrame
            context.saveGState()
            context.clip(to: symbolRect)
            context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

            WatchStatsDrawer.drawActivityRed2(wellnessLevel: wellnessLevel, frame: CGRect(origin: .zero, size: symbolRect.size), resizing: resizing)
            context.restoreGState()


            context.endTransparencyLayer()
            context.restoreGState()


            //// Oval Drawing
            let ovalPath = UIBezierPath(ovalIn: CGRect(x: 22, y: 44, width: 112, height: 112))
            UIColor.black.setFill()
            ovalPath.fill()


            //// Picture Drawing
            context.saveGState()
            context.translateBy(x: 71, y: 28)
            context.scaleBy(x: 0.15, y: 0.15)

            let picturePath = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 100, height: 100))
            context.saveGState()
            picturePath.addClip()
            context.translateBy(x: 0, y: 0)
            context.scaleBy(x: 1, y: -1)
    //        context.translateBy(x: 0, y: -hearth.size.height)
    //        context.draw(hearth.cgImage!, in: CGRect(x: 0, y: 0, width: hearth.size.width, height: hearth.size.height))
            context.restoreGState()

            context.restoreGState()


            //// Picture 2 Drawing
            context.saveGState()
            context.translateBy(x: 71, y: 46.92)
            context.scaleBy(x: 0.11, y: 0.11)

            let picture2Path = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 128, height: 128))
            context.saveGState()
            picture2Path.addClip()
            context.translateBy(x: 0, y: 0)
            context.scaleBy(x: 1, y: -1)
    //        context.translateBy(x: 0, y: -footstepssilhouettevariant.size.height)
    //        context.draw(footstepssilhouettevariant.cgImage!, in: CGRect(x: 0, y: 0, width: footstepssilhouettevariant.size.width, height: footstepssilhouettevariant.size.height))
            context.restoreGState()

            context.restoreGState()


            //// Picture 3 Drawing
            context.saveGState()
            context.translateBy(x: 70, y: 63.44)
            context.scaleBy(x: 0.06, y: 0.06)

            let picture3Path = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 280, height: 276))
            context.saveGState()
            picture3Path.addClip()
            context.translateBy(x: 0, y: 0)
            context.scaleBy(x: 1, y: -1)
    //        context.translateBy(x: 0, y: -halfmoon.size.height)
    //        context.draw(halfmoon.cgImage!, in: CGRect(x: 0, y: 0, width: halfmoon.size.width, height: halfmoon.size.height))
            context.restoreGState()

            context.restoreGState()
            
            let cgimage = context.makeImage();
            return UIImage(cgImage: cgimage!)
            
    //        return UIImage(cgImage: context.makeImage()!)
        }

    
    @objc public dynamic class func drawActivityRed3(wellnessLevel: CGFloat = 0.163, frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 156, height: 195), resizing: ResizingBehavior = .aspectFit) {
            //// General Declarations
            let context = UIGraphicsGetCurrentContext()!
            
            //// Resize to Target Frame
            context.saveGState()
            let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 156, height: 195), target: targetFrame)
            context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
            context.scaleBy(x: resizedFrame.width / 156, y: resizedFrame.height / 195)


            //// Color Declarations
            let wellness1 = UIColor(red: 0.200, green: 0.000, blue: 0.000, alpha: 1.000)
    //        let wellness2 = UIColor(red: 1.000, green: 0.082, blue: 0.035, alpha: 1.000)
            
            //// Gradient Declarations
    //        let wellnessgradient = CGGradient(colorsSpace: nil, colors: [wellness1.cgColor, wellness2.cgColor] as CFArray, locations: [0, 1])!
            
            //// Variable Declarations
            let wellnessDash: CGFloat = wellnessLevel * 408 + 6

            //// ColorGroup
            //// MaskOval Drawing
            let maskOvalPath = UIBezierPath(ovalIn: CGRect(x: 4, y: 26, width: 148, height: 148))
            context.saveGState()
            maskOvalPath.addClip()
            wellness1.setFill()
            maskOvalPath.fill()
    //        context.drawLinearGradient(wellnessgradient, start: CGPoint(x: 78, y: 26), end: CGPoint(x: 78, y: 174), options: [])
            context.restoreGState()



            //// MaskGroup
            context.saveGState()
            context.translateBy(x: 78, y: 100)
            context.rotate(by: 90 * CGFloat.pi/180)

            context.setBlendMode(.destinationIn)
            context.beginTransparencyLayer(auxiliaryInfo: nil)


            //// MoveMask Drawing
            let moveMaskPath = UIBezierPath()
            moveMaskPath.move(to: CGPoint(x: -65, y: 0))
            moveMaskPath.addCurve(to: CGPoint(x: 0, y: -65), controlPoint1: CGPoint(x: -65, y: -35.9), controlPoint2: CGPoint(x: -35.9, y: -65))
            moveMaskPath.addCurve(to: CGPoint(x: 65, y: 0), controlPoint1: CGPoint(x: 35.9, y: -65), controlPoint2: CGPoint(x: 65, y: -35.9))
            moveMaskPath.addCurve(to: CGPoint(x: -0, y: 65), controlPoint1: CGPoint(x: 65, y: 35.9), controlPoint2: CGPoint(x: 35.9, y: 65))
            moveMaskPath.addCurve(to: CGPoint(x: -65, y: 0), controlPoint1: CGPoint(x: -35.9, y: 65), controlPoint2: CGPoint(x: -65, y: 35.9))
            moveMaskPath.close()
            UIColor.black.setStroke()
            moveMaskPath.lineWidth = 19
            moveMaskPath.lineCapStyle = .round
            context.saveGState()
            context.setLineDash(phase: 1, lengths: [wellnessDash, 408])
            moveMaskPath.stroke()
            context.restoreGState()

            context.endTransparencyLayer()

            context.restoreGState()
            
            context.restoreGState()

        }

        @objc public dynamic class func drawActivityCompositionRed3(wellnessLevel: CGFloat = 0.163, frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 156, height: 195), resizing: ResizingBehavior = .aspectFit) -> UIImage {
            //// General Declarations
            let context = UIGraphicsGetCurrentContext()!

            //// Color Declarations
            let wellness1 = UIColor(red: 0.898, green: 0.000, blue: 0.000, alpha: 1.000)
            var wellness1HueComponent: CGFloat = 1
            var wellness1SaturationComponent: CGFloat = 1
            var wellness1BrightnessComponent: CGFloat = 1
            wellness1.getHue(&wellness1HueComponent, saturation: &wellness1SaturationComponent, brightness: &wellness1BrightnessComponent, alpha: nil)

    //        let wellnessBkg = UIColor(red: 0.110, green: 1.000, blue: 0.078, alpha: 1.000)
            
            //// Image Declarations
            /*let hearth = UIImage(named: "hearth.png")!
            let footstepssilhouettevariant = UIImage(named: "footstepssilhouettevariant.png")!
            let halfmoon = UIImage(named: "halfmoon.png")!*/

            //// ColorGroup
            //// MaskOval Drawing
            let maskOvalPath = UIBezierPath(ovalIn: CGRect(x: 4, y: 26, width: 148, height: 148))
            wellness1.setFill()
            maskOvalPath.fill()


            //// SymbolGroup
            context.saveGState()
            context.setBlendMode(.sourceAtop)
            context.beginTransparencyLayer(auxiliaryInfo: nil)


            //// Symbol Drawing
            let symbolRect = targetFrame
            context.saveGState()
            context.clip(to: symbolRect)
            context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

            WatchStatsDrawer.drawActivityRed3(wellnessLevel: wellnessLevel, frame: CGRect(origin: .zero, size: symbolRect.size), resizing: resizing)
            context.restoreGState()


            context.endTransparencyLayer()
            context.restoreGState()


            //// Oval Drawing
            let ovalPath = UIBezierPath(ovalIn: CGRect(x: 22, y: 44, width: 112, height: 112))
            UIColor.black.setFill()
            ovalPath.fill()


            //// Picture Drawing
            context.saveGState()
            context.translateBy(x: 71, y: 28)
            context.scaleBy(x: 0.15, y: 0.15)

            let picturePath = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 100, height: 100))
            context.saveGState()
            picturePath.addClip()
            context.translateBy(x: 0, y: 0)
            context.scaleBy(x: 1, y: -1)
    //        context.translateBy(x: 0, y: -hearth.size.height)
    //        context.draw(hearth.cgImage!, in: CGRect(x: 0, y: 0, width: hearth.size.width, height: hearth.size.height))
            context.restoreGState()

            context.restoreGState()


            //// Picture 2 Drawing
            context.saveGState()
            context.translateBy(x: 71, y: 46.92)
            context.scaleBy(x: 0.11, y: 0.11)

            let picture2Path = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 128, height: 128))
            context.saveGState()
            picture2Path.addClip()
            context.translateBy(x: 0, y: 0)
            context.scaleBy(x: 1, y: -1)
    //        context.translateBy(x: 0, y: -footstepssilhouettevariant.size.height)
    //        context.draw(footstepssilhouettevariant.cgImage!, in: CGRect(x: 0, y: 0, width: footstepssilhouettevariant.size.width, height: footstepssilhouettevariant.size.height))
            context.restoreGState()

            context.restoreGState()


            //// Picture 3 Drawing
            context.saveGState()
            context.translateBy(x: 70, y: 63.44)
            context.scaleBy(x: 0.06, y: 0.06)

            let picture3Path = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 280, height: 276))
            context.saveGState()
            picture3Path.addClip()
            context.translateBy(x: 0, y: 0)
            context.scaleBy(x: 1, y: -1)
    //        context.translateBy(x: 0, y: -halfmoon.size.height)
    //        context.draw(halfmoon.cgImage!, in: CGRect(x: 0, y: 0, width: halfmoon.size.width, height: halfmoon.size.height))
            context.restoreGState()

            context.restoreGState()
            
            let cgimage = context.makeImage();
            return UIImage(cgImage: cgimage!)
            
    //        return UIImage(cgImage: context.makeImage()!)
        }


    
    @objc public dynamic class func drawActivityGreen(wellnessLevel: CGFloat = 0.163, frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 156, height: 195), resizing: ResizingBehavior = .aspectFit) {
            //// General Declarations
            let context = UIGraphicsGetCurrentContext()!
            
            //// Resize to Target Frame
            context.saveGState()
            let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 156, height: 195), target: targetFrame)
            context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
            context.scaleBy(x: resizedFrame.width / 156, y: resizedFrame.height / 195)


            //// Color Declarations
            let wellness1 = UIColor(red: 0.086, green: 0.800, blue: 0.063, alpha: 1.000)
//            let wellness2 = UIColor(red: 0.110, green: 1.000, blue: 0.078, alpha: 1.000)
            
            //// Gradient Declarations
//            let wellnessgradient = CGGradient(colorsSpace: nil, colors: [wellness1.cgColor, wellness2.cgColor] as CFArray, locations: [0, 1])!
            
            //// Variable Declarations
            let wellnessDash: CGFloat = wellnessLevel * 408 + 6

            //// ColorGroup
            //// MaskOval Drawing
            let maskOvalPath = UIBezierPath(ovalIn: CGRect(x: 4, y: 26, width: 148, height: 148))
            context.saveGState()
            maskOvalPath.addClip()
        wellness1.setFill()
        maskOvalPath.fill()
//            context.drawLinearGradient(wellnessgradient, start: CGPoint(x: 78, y: 26), end: CGPoint(x: 78, y: 174), options: [])
            context.restoreGState()



            //// MaskGroup
            context.saveGState()
            context.translateBy(x: 78, y: 100)
            context.rotate(by: 90 * CGFloat.pi/180)

            context.setBlendMode(.destinationIn)
            context.beginTransparencyLayer(auxiliaryInfo: nil)


            //// MoveMask Drawing
            let moveMaskPath = UIBezierPath()
            moveMaskPath.move(to: CGPoint(x: -65, y: 0))
            moveMaskPath.addCurve(to: CGPoint(x: 0, y: -65), controlPoint1: CGPoint(x: -65, y: -35.9), controlPoint2: CGPoint(x: -35.9, y: -65))
            moveMaskPath.addCurve(to: CGPoint(x: 65, y: 0), controlPoint1: CGPoint(x: 35.9, y: -65), controlPoint2: CGPoint(x: 65, y: -35.9))
            moveMaskPath.addCurve(to: CGPoint(x: -0, y: 65), controlPoint1: CGPoint(x: 65, y: 35.9), controlPoint2: CGPoint(x: 35.9, y: 65))
            moveMaskPath.addCurve(to: CGPoint(x: -65, y: 0), controlPoint1: CGPoint(x: -35.9, y: 65), controlPoint2: CGPoint(x: -65, y: 35.9))
            moveMaskPath.close()
            UIColor.black.setStroke()
            moveMaskPath.lineWidth = 17
            moveMaskPath.lineCapStyle = .round
            context.saveGState()
            context.setLineDash(phase: 1, lengths: [wellnessDash, 408])
            moveMaskPath.stroke()
            context.restoreGState()

            context.endTransparencyLayer()

            context.restoreGState()
            
            context.restoreGState()

        }

        @objc public dynamic class func drawActivityCompositionGreen(wellnessLevel: CGFloat = 0.163, frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 156, height: 195), resizing: ResizingBehavior = .aspectFit) -> UIImage {
            //// General Declarations
            let context = UIGraphicsGetCurrentContext()!

            //// Color Declarations
            let wellness1 = UIColor(red: 0.086, green: 0.800, blue: 0.063, alpha: 1.000)
            var wellness1HueComponent: CGFloat = 1
            var wellness1SaturationComponent: CGFloat = 1
            var wellness1BrightnessComponent: CGFloat = 1
            wellness1.getHue(&wellness1HueComponent, saturation: &wellness1SaturationComponent, brightness: &wellness1BrightnessComponent, alpha: nil)

            let wellnessBkg = UIColor(red: 0.027, green: 0.259, blue: 0.020, alpha: 1.000)
            
            //// Image Declarations
            /*let hearth = UIImage(named: "hearth.png")!
            let footstepssilhouettevariant = UIImage(named: "footstepssilhouettevariant.png")!
            let halfmoon = UIImage(named: "halfmoon.png")!*/

            //// ColorGroup
            //// MaskOval Drawing
            let maskOvalPath = UIBezierPath(ovalIn: CGRect(x: 4, y: 26, width: 148, height: 148))
            wellnessBkg.setFill()
            maskOvalPath.fill()


            //// SymbolGroup
            context.saveGState()
            context.setBlendMode(.sourceAtop)
            context.beginTransparencyLayer(auxiliaryInfo: nil)


            //// Symbol Drawing
            let symbolRect = targetFrame
            context.saveGState()
            context.clip(to: symbolRect)
            context.translateBy(x: symbolRect.minX, y: symbolRect.minY)

            WatchStatsDrawer.drawActivityGreen(wellnessLevel: wellnessLevel, frame: CGRect(origin: .zero, size: symbolRect.size), resizing: resizing)
            context.restoreGState()


            context.endTransparencyLayer()
            context.restoreGState()


            //// Oval Drawing
            let ovalPath = UIBezierPath(ovalIn: CGRect(x: 22, y: 44, width: 112, height: 112))
            UIColor.black.setFill()
            ovalPath.fill()


            //// Picture Drawing
            context.saveGState()
            context.translateBy(x: 71, y: 28)
            context.scaleBy(x: 0.15, y: 0.15)

            let picturePath = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 100, height: 100))
            context.saveGState()
            picturePath.addClip()
            context.translateBy(x: 0, y: 0)
            context.scaleBy(x: 1, y: -1)
    //        context.translateBy(x: 0, y: -hearth.size.height)
    //        context.draw(hearth.cgImage!, in: CGRect(x: 0, y: 0, width: hearth.size.width, height: hearth.size.height))
            context.restoreGState()

            context.restoreGState()


            //// Picture 2 Drawing
            context.saveGState()
            context.translateBy(x: 71, y: 46.92)
            context.scaleBy(x: 0.11, y: 0.11)

            let picture2Path = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 128, height: 128))
            context.saveGState()
            picture2Path.addClip()
            context.translateBy(x: 0, y: 0)
            context.scaleBy(x: 1, y: -1)
    //        context.translateBy(x: 0, y: -footstepssilhouettevariant.size.height)
    //        context.draw(footstepssilhouettevariant.cgImage!, in: CGRect(x: 0, y: 0, width: footstepssilhouettevariant.size.width, height: footstepssilhouettevariant.size.height))
            context.restoreGState()

            context.restoreGState()


            //// Picture 3 Drawing
            context.saveGState()
            context.translateBy(x: 70, y: 63.44)
            context.scaleBy(x: 0.06, y: 0.06)

            let picture3Path = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 280, height: 276))
            context.saveGState()
            picture3Path.addClip()
            context.translateBy(x: 0, y: 0)
            context.scaleBy(x: 1, y: -1)
    //        context.translateBy(x: 0, y: -halfmoon.size.height)
    //        context.draw(halfmoon.cgImage!, in: CGRect(x: 0, y: 0, width: halfmoon.size.width, height: halfmoon.size.height))
            context.restoreGState()

            context.restoreGState()
            
            let cgimage = context.makeImage();
            return UIImage(cgImage: cgimage!)
            
    //        return UIImage(cgImage: context.makeImage()!)
        }




        @objc(StatsWatchResizingBehavior)
        public enum ResizingBehavior: Int {
            case aspectFit /// The content is proportionally resized to fit into the target rectangle.
            case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
            case stretch /// The content is stretched to match the entire target rectangle.
            case center /// The content is centered in the target rectangle, but it is NOT resized.

            public func apply(rect: CGRect, target: CGRect) -> CGRect {
                if rect == target || target == CGRect.zero {
                    return rect
                }

                var scales = CGSize.zero
                scales.width = abs(target.width / rect.width)
                scales.height = abs(target.height / rect.height)

                switch self {
                    case .aspectFit:
                        scales.width = min(scales.width, scales.height)
                        scales.height = scales.width
                    case .aspectFill:
                        scales.width = max(scales.width, scales.height)
                        scales.height = scales.width
                    case .stretch:
                        break
                    case .center:
                        scales.width = 1
                        scales.height = 1
                }

                var result = rect.standardized
                result.size.width *= scales.width
                result.size.height *= scales.height
                result.origin.x = target.minX + (target.width - result.width) / 2
                result.origin.y = target.minY + (target.height - result.height) / 2
                return result
            }
        }
}
